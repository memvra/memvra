package export

import (
	"fmt"
	"strings"

	"github.com/memvra/memvra/internal/memory"
)

// ClaudeMDExporter renders context in CLAUDE.md format.
type ClaudeMDExporter struct{}

func (e *ClaudeMDExporter) Export(data ExportData) (string, error) {
	ts := data.Stack
	proj := data.Project

	var b strings.Builder
	fmt.Fprintf(&b, "# %s â€” Project Context\n\n", proj.Name)
	fmt.Fprintf(&b, "> Generated by [Memvra](https://memvra.com). Do not edit manually.\n\n")
	fmt.Fprintf(&b, "## Project Profile\n\n")

	if ts.Language != "" {
		fmt.Fprintf(&b, "- **Language:** %s\n", ts.Language)
	}
	if ts.Framework != "" {
		fmt.Fprintf(&b, "- **Framework:** %s\n", ts.Framework)
	}
	if ts.Database != "" {
		fmt.Fprintf(&b, "- **Database:** %s\n", ts.Database)
	}
	if ts.Architecture != "" {
		fmt.Fprintf(&b, "- **Architecture:** %s\n", ts.Architecture)
	}
	if ts.TestFramework != "" {
		fmt.Fprintf(&b, "- **Test framework:** %s\n", ts.TestFramework)
	}
	if len(ts.DetectedPatterns) > 0 {
		fmt.Fprintf(&b, "- **Patterns:** %s\n", strings.Join(ts.DetectedPatterns, ", "))
	}
	b.WriteString("\n")

	b.WriteString(memorySection("Architectural Decisions", memory.TypeDecision, data.Memories))
	b.WriteString(memorySection("Coding Conventions", memory.TypeConvention, data.Memories))
	b.WriteString(memorySection("Constraints", memory.TypeConstraint, data.Memories))
	b.WriteString(memorySection("Notes", memory.TypeNote, data.Memories))
	b.WriteString(memorySection("TODOs", memory.TypeTodo, data.Memories))

	return b.String(), nil
}
