package export

import (
	"fmt"
	"strings"

	"github.com/memvra/memvra/internal/memory"
)

const mcpInstructions = `## Memvra Integration

This project uses [Memvra](https://memvra.com) for persistent AI memory across sessions. If Memvra MCP tools are available, use them:

- **memvra_save_progress** — Call before ending a session to save what you worked on so the next AI can continue
- **memvra_remember** — Store important decisions, conventions, or constraints
- **memvra_get_context** — Retrieve relevant project context for your current task
- **memvra_search** — Search code and memories semantically

`

// ClaudeMDExporter renders context in CLAUDE.md format.
type ClaudeMDExporter struct{}

func (e *ClaudeMDExporter) Export(data ExportData) (string, error) {
	ts := data.Stack
	proj := data.Project

	var b strings.Builder
	fmt.Fprintf(&b, "# %s — Project Context\n\n", proj.Name)
	fmt.Fprintf(&b, "> Generated by [Memvra](https://memvra.com). Do not edit manually.\n\n")

	b.WriteString(mcpInstructions)

	b.WriteString(renderGitStateMarkdown(data.GitState))
	b.WriteString(renderSessionsMarkdown(data.Sessions))

	fmt.Fprintf(&b, "## Project Profile\n\n")

	if ts.Language != "" {
		fmt.Fprintf(&b, "- **Language:** %s\n", ts.Language)
	}
	if ts.Framework != "" {
		fmt.Fprintf(&b, "- **Framework:** %s\n", ts.Framework)
	}
	if ts.Database != "" {
		fmt.Fprintf(&b, "- **Database:** %s\n", ts.Database)
	}
	if ts.Architecture != "" {
		fmt.Fprintf(&b, "- **Architecture:** %s\n", ts.Architecture)
	}
	if ts.TestFramework != "" {
		fmt.Fprintf(&b, "- **Test framework:** %s\n", ts.TestFramework)
	}
	if len(ts.DetectedPatterns) > 0 {
		fmt.Fprintf(&b, "- **Patterns:** %s\n", strings.Join(ts.DetectedPatterns, ", "))
	}
	b.WriteString("\n")

	b.WriteString(memorySection("Architectural Decisions", memory.TypeDecision, data.Memories))
	b.WriteString(memorySection("Coding Conventions", memory.TypeConvention, data.Memories))
	b.WriteString(memorySection("Constraints", memory.TypeConstraint, data.Memories))
	b.WriteString(memorySection("Notes", memory.TypeNote, data.Memories))
	b.WriteString(memorySection("TODOs", memory.TypeTodo, data.Memories))

	return b.String(), nil
}
