package export

import (
	"fmt"
	"strings"

	"github.com/memvra/memvra/internal/memory"
)

// CursorRulesExporter renders context in .cursorrules format.
type CursorRulesExporter struct{}

func (e *CursorRulesExporter) Export(data ExportData) (string, error) {
	ts := data.Stack
	proj := data.Project

	var b strings.Builder
	fmt.Fprintf(&b, "# %s â€” AI Rules\n", proj.Name)
	fmt.Fprintf(&b, "# Generated by Memvra (https://memvra.com)\n\n")

	b.WriteString(renderGitStatePlainText(data.GitState))
	b.WriteString(renderSessionsPlainText(data.Sessions))

	// Cursor rules are plain text instructions, not markdown.
	if ts.Language != "" {
		fmt.Fprintf(&b, "This is a %s project", ts.Language)
		if ts.Framework != "" {
			fmt.Fprintf(&b, " using %s", ts.Framework)
		}
		fmt.Fprintf(&b, ".\n")
	}
	if ts.Database != "" {
		fmt.Fprintf(&b, "The database is %s.\n", ts.Database)
	}
	if ts.Architecture != "" {
		fmt.Fprintf(&b, "Architecture pattern: %s.\n", ts.Architecture)
	}
	b.WriteString("\n")

	for _, memType := range []struct {
		label string
		mt    memory.MemoryType
	}{
		{"Architectural Decisions", memory.TypeDecision},
		{"Coding Conventions", memory.TypeConvention},
		{"Constraints", memory.TypeConstraint},
		{"Notes", memory.TypeNote},
	} {
		items := filterByType(data.Memories, memType.mt)
		if len(items) == 0 {
			continue
		}
		fmt.Fprintf(&b, "# %s\n", memType.label)
		for _, m := range items {
			fmt.Fprintf(&b, "- %s\n", m.Content)
		}
		b.WriteString("\n")
	}

	return b.String(), nil
}

func filterByType(memories []memory.Memory, mt memory.MemoryType) []memory.Memory {
	var out []memory.Memory
	for _, m := range memories {
		if m.MemoryType == mt {
			out = append(out, m)
		}
	}
	return out
}
